(ns selling.common
  "Utility functions. Time/date, some flow control constructs, protocol buffer
  definitions and codecs, some vector set ops, etc."
  (:use [selling.time :only [unix-time]]))

(defprotocol Match
  (match [pred object]
    "Does predicate describe object?"))

(defn map-matches?
  "Does the given map pattern match obj?"
  [pat obj]
    (every? (fn [[k v]] (match v (get obj k))) pat))

(comment
  ;; Some examples
  ;; Fn
  (prn (match (fn [x] (= x 1)) 1))
  (prn (match (fn [x] (= x 1)) 3))
  ;; Var
  (defn g [x] (= x 42))
  (prn (match g 42))
  (prn (match g 40))
  ;; default
  (prn (match 42 42))
  (prn (match 42 :forty-two))
  ;; nil
  (prn (match nil nil))
  (prn (match nil 1)))

; Matching
(extend-protocol Match
  ; Regexes are matched against strings.
  erlang.util.Regex
  (match [re string]
    (try (re-find re string)
         (catch _ _ false)))

  ; Functions are called with the given object.
  erlang.Fn
  (match [f obj]
    (f obj))

  clojerl.Fn
  (match [f obj]
    (f obj))

  clojerl.Var
  (match [f obj]
    (f obj))

  ; Map types
  clojerl.TupleMap ;; clojure.lang.PersistentArrayMap
    (match [pat obj] (map-matches? pat obj))

  clojerl.Map ;; clojure.lang.PersistentHashMap
  (match [pat obj] (map-matches? pat obj))
  
  clojerl.SortedMap ;; clojure.lang.PersistentTreeMap
  (match [pat obj] (map-matches? pat obj))

  ; Falls back to object equality
  default ;; java.lang.Object
  (match [pred object] (= pred object))
  
  ; Nils match nils only.
  nil
  (match [_ object] (nil? object)))

; Vector set operations
(defn member?
  "Is r present in seqable s?"
  [r s]
  (some (fn [e] (= r e)) s))

(defn pkey
  "Primary key for an event."
  [event]
  [(:host event) (:service event)])

(defn expire
  "An expired version of an event."
  [event]
  (into (select-keys event [:host :service])
    [[:time (unix-time)] [:state "expired"]]))

(defrecord Event [host service state description metric tags time ttl])

(defn event
  "Create a new event from a map."
  [opts]
  (let [t (int (erlang/round (or (opts :time)
                           (unix-time))))]
    (map->Event (merge opts {:time t}))))

(defn approx-equal
  "Returns true if x and y are roughly equal, such that x/y is within tol of
  unity."
([x,y]
  (approx-equal x y 0.01))
([x, y, tol]
  (if (= x y) true
    (let [f (try (/ x y) (catch _ e (/ y x)))]
      (< (- 1 tol) f (inc tol))))))